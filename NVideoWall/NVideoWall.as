package {    import flash.display.*;    import flash.events.*;    import flash.media.*;		import flash.media.Camera;		// classes dynamic podem ter propriedades		// que são definidas em run-time    dynamic public class NVideoWall extends MovieClip    {						  // dimensoes da imagem a daquirir				const _CAM_W		:int 		= 160;				const _CAM_H		:int		= 120;								// dimensões do stage (				const _STAGE_W 	:int		= stage.stageWidth;				const _STAGE_H	:int 		= stage.stageHeight;								// numero de imagens (linhas e colunas)				const _NCAMS_W	:uint		= Math.floor(_STAGE_W / _CAM_W);				const _NCAMS_H	:uint		= Math.floor(_STAGE_H / _CAM_H);								// numero total de imagens				const _CAMS			:uint		= _NCAMS_H * _NCAMS_W;				const _WCFPS		:uint		= 15;								// array de imagens				var 	camArray	:Array	= new Array();        				// objecto video				var 	vid		:Video;       			  // objecto webcam        var 	cam		:Camera;		// Input Video Camera				        public function NVideoWall()        {						trace(_NCAMS_W,_NCAMS_H);						init();            return;        }//Para a primeira frame        function init()        {            // a camara						cam = Camera.getCamera();						// modo da camara            cam.setMode(_CAM_W, _CAM_H, _WCFPS, false);            cam.setQuality(10000, 0);						// associar a um video	            vid = new Video(_CAM_W, _CAM_H);            vid.attachCamera(cam);            vid.smoothing = true;            //Matriz de imagens												for(var i=0; i<_CAMS;i++) {							var theBMPData  : BitmapData = new BitmapData(_CAM_W,_CAM_H,false,0);							theBMPData.draw(vid);							var theBMP			: Bitmap = new Bitmap(theBMPData);							camArray.push(theBMP);						}												geraMatrixCameras();									            this.addEventListener(Event.ENTER_FRAME, ciclo);            stage.addEventListener(Event.RESIZE, renovaPosicoes);            return;        }        public function geraMatrixCameras()        {											for(var lin = 0; lin < _NCAMS_H; lin ++) {							for (var col = 0; col < _NCAMS_W; col ++) {								var idx		 : uint		= lin*_NCAMS_W + col;								var theBMP : Bitmap = camArray[idx] as Bitmap;								var theBMPY: uint		= _CAM_H * lin;								var theBMPX: uint;								if ((lin % 2) == 0) {									theBMPX = _CAM_W * col;								} else {									theBMPX = _CAM_W * (col + 1);									theBMP.scaleX = -1;								}								theBMP.x = theBMPX;								theBMP.y = theBMPY;								trace((lin % 2),idx,theBMP.x,theBMP.y);								addChild(theBMP);							}						}            return;        }		        public function ciclo(event:Event) : void        {											// novo bitmadata para a imagem actual						var newBMPData : BitmapData = new BitmapData(_CAM_W,_CAM_H,false,0);						// novo bitmap para a imagem actual						var newBMP		 : Bitmap			= new Bitmap(newBMPData);						// capturar a imagem actual a partir do elemento video						newBMPData.draw(vid);						// inserir imagem actual						camArray.unshift(newBMP);						// retirar imagem mais antiga						camArray.pop();						// adicionar para visualização o bitmap mais recente						addChildAt(newBMP,0);						// retirar de visualização o bitmap mais antigo						removeChildAt(numChildren-1);												// reposiciona-los no stage						for(var lin = 0; lin < _NCAMS_H; lin++) {							for (var col=0; col < _NCAMS_W; col++) {								var idx		 : uint		= lin*_NCAMS_W + col;								var theBMP : Bitmap = camArray[idx] as Bitmap;								var theBMPY: uint		= _CAM_H * lin;								var theBMPX: uint;																// inverte na horizontal em linhas alternadas								if ((lin % 2) == 0) {									theBMPX = _CAM_W * col;									theBMP.scaleX = 1.0;								} else {									theBMPX = _CAM_W * (col + 1);									theBMP.scaleX = -1.0;								}																theBMP.x = theBMPX;								theBMP.y = theBMPY;																//trace((lin %2),idx,theBMP.x,theBMP.y);							}						}            return;        }// end function        public function renovaPosicoes(event:Event)        {            geraMatrixCameras();            return;        }// end function								    }}
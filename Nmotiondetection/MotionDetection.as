package {/** * (c) 2009-2012 pedro moreira ESTG-IPVC ***/ 	import flash.display.MovieClip;	import flash.display.StageAlign	import flash.display.StageScaleMode	import flash.display.BitmapData	import flash.display.Bitmap	import flash.utils.setInterval	import flash.text.TextField	import flash.media.Camera	import flash.media.Video	import flash.geom.Point	import flash.geom.Rectangle	import flash.events.Event;	import flash.utils.getTimer;	import flash.display.Sprite;	import flash.display.Graphics;	public class MotionDetection extends MovieClip {		private var cam		:Camera;			  // video input device		private var video	:Video;				  // video object		private var now		:BitmapData;		// image pixel data (current)		private var prev	:BitmapData;		// image pixel (previous)		private var diff	:BitmapData;		// image pixel (difference)		private var out		:BitmapData;		// image pixel (motion)		private var label	:TextField;				private var camFPS	:Number 	= 15;					  // cam frames per second		private var camW	:Number 	  = 80;						// cam capture width		private var camH	:Number 	  = 60;						// cam capture height		private var aspect : Number   = camW / camH;	// aspect ratio		private var originX : Number  = camW / 2;		  // center coord X		private var originY : Number  = camH / 2;		  // center coord y				private var track : tracker;				// tracker class				// stage regions		private var up = 0;			private var down = 0;		private var left = 0;		private var right = 0;				// 		// private var deltapos = 5;				// the ball to be motion-based controllable		private var bb: Sprite;		public function MotionDetection () {			bb = doBall();														// init ball			bb.x = stage.stageWidth / 2;							// place it at center 			bb.y = stage.stageHeight /2;						// get camera			cam = Camera.getCamera();			// set the mode : width, height, frames per second			cam.setMode(camW, camH, camFPS);			// set movie FPS equal to cam FPS			stage.frameRate=camFPS;			// check if a camera was detected			if (cam == null) {				label = new TextField();				label.text = "NO WEBCAM";				addChild(label);			} else {				// instantiate a new video (original)				video = new Video(cam.width, cam.height);				// attach the web cam				video.attachCamera(cam);				// display it @ stage				// flip horizontally (visual understanding is easier)				video.scaleX = -1;				// position				video.x = video.width;				// show it @ stage				addChild(video);								// create four images (BitmapData)				// with the same dimensions of the video/camera mode				now  = new BitmapData(video.width, video.height);				out  = new BitmapData(video.width, video.height);				diff = new BitmapData(video.width, video.height);				prev = new BitmapData(video.width, video.height);				// create and display these Bitmaps @ stage (flipped horizontally)								// previous video image				var previous = addChild(new Bitmap(prev));				previous.scaleX = -1;				previous.x = video.width + video.width;								// difference video image				var diffBitmap = addChild(new Bitmap(diff));				diffBitmap.scaleX = -1;				diffBitmap.x += video.width;				diffBitmap.y = video.height;								// motion detected video image				var output = addChild(new Bitmap(out));				output.scaleX = -1;				output.x = video.width + video.width;				output.y = video.height;								// the tracker				track = new tracker(video.width * 0.5, video.height * 0.5);								// to update every image and the motion				addEventListener(Event.ENTER_FRAME,render);			}		}		private function render (ev:Event):void {			// time benchmarks			var ti = getTimer();						// if there is no camera working return			if (!cam.currentFPS) return;						//  --- redraw the BitmapData						// current image			now.draw(video);						// fill the diff bitmap with the current frame			diff.draw(video);						// make the difference between the current and previous			// uses a blend filter to achieve differences			diff.draw(prev,null,null,"difference");						// fills the output bitmap with blacks			// 0xAARRGGBB (A-Alpha, R-Red, G-Green, B-Blue)			out.fillRect(out.rect ,0xFF000000);			// redraws pixels above threshold with red			// see documentation			out.threshold(diff, out.rect, new Point(0,0), ">", 0xFF333333, 0xFFFF0000);						// fills the previous with the current frame			prev.draw(video);						// get the average coordinates of the pixels where motion was detected			var p = motionDetector(out);						// tracks the motion (time based filter)			// avoids or tries to atenuate quick changes			var pt = track.update(p);						// analyses motion and (for now) tells where it has been detected			motionAnalyserXY(pt);						// moves the ball according to the detected motion			bb.x -= (pt.x - originX) / (camW / 2) * 20 / aspect;			bb.y += (pt.y - originY) / (camH / 2) * 20;						// draw the rectangles			// rectangle centered on p (coordinate of the current detection) - light blue			// rectangle after time based filter - yellow						out.fillRect(new Rectangle(p.x-5,p.y-5,11,11),0xFF5555FF);			out.fillRect(new Rectangle(pt.x-5,pt.y-5,11,11),0xFFFFFF00);						// how many time has elapsed			var tf = getTimer();			//trace("time to complete : ", ti,"  ",tf, "  ", (tf-ti));		}						private function motionAnalyserXY(p:Point):void {			// center			var midx 		= camW / 2;			var midy 		= camH / 2;			// adjust the center rectangle dimensions			var sensex 	= camW / 5;			var sensey 	= camH / 5;									/*			|-------------|			| UL | U | UR |			|-------------|			| L  | C | R  |			|-------------|			| DL | D | DR |			|-------------|			*/						// trace(midx);			// trace(midy);						var xf = false;			var yf = false;						up = down = right = left = 0;			// up or down			if (p.x > midx + sensex) {trace ("--left--"); left = 1; xf = true;}			else if (p.x < midx - sensex) {trace("--right--"); right = 1; xf = true;}			else {xf = false}			// right or left			if (p.y > midy + sensey) {trace ("--down--"); down = 1; yf = true;}			else if (p.y < midy - sensey) {trace("--up--"); up = 1; yf = true;}			else {yf = false}			// no motion			if (xf == false && yf == false) trace("-- stop--");					}			// just to analyse and	// identify where motion is being detected	private function motionAnalyserVector(p:Point):void {			var midx = camW / 2;			var midy = camH / 2;						// defines the size of the center region in respect to image size			var sensex = camW * .15;			var sensey = camH * .15;						// image is divided in 9 differente regions						// horizontally : left (L) - center (C) - right (R)			// vertically   : up (U) - center (C) - down (D)						/*			|-------------|			| UL | U | UR |			|-------------|			| L  | C | R  |			|-------------|			| DL | D | DR |			|-------------|			*/						var xf = false;			var yf = false;			up = down = right = left = 0;			// up or down			if (p.x > midx + sensex) {trace ("--right--"); left = 1; xf = true;}			else if (p.x < midx - sensex) {trace("--left--"); right = 1; xf = true;}			else {xf = false}			if (p.y > midy + sensey) {trace ("--up--"); down = 1; yf = true;}			else if (p.y < midy - sensey) {trace("--down--"); up = 1; yf = true;}			else {yf = false}			if (xf == false && yf == false) trace("-- center--");					}					// Creates a ball (Sprite)		private function doBall() : Sprite{			var ball:Sprite = new Sprite();			//ball.graphics = new Graphics();			ball.graphics.beginFill(0xFFFF0000);			ball.graphics.drawCircle(0,0,20);			ball.graphics.endFill();			addChild(ball);			return ball;		}				// this is the motion detector		// returns a Point (x,y)		private function motionDetector(bit:BitmapData) : Point{						// operates over the out image						// the Point			var p = new Point();			// accumulators			// acc x coordinates			var accx = 0;			// acc y coordinates			var accy = 0;			// acc number of pixels			var accn = 0;						//trace("w",bit.width);			//trace("h",bit.height);						// iterate all over the difference image			// (or over a region - not implemented)			for(var i = 0; i < bit.width ; i++) {				for(var j = 0; j < bit.height; j++) {					var pix = bit.getPixel32(i,j);					// remenber that motion pixels where painted red					if (pix == 0xFFFF0000) {						accx += i;						accy += j;						accn ++;					}				}			}			// if there are at least one pixel			// evaluate the average coordinate			if (accn != 0) {				p.x = accx/accn;				p.y = accy/accn;			} else {			// if no motion - return the center coordinate				p.x = bit.width / 2;				p.y = bit.height / 2;			}			return p;		}	}}// internal use only	import flash.display.MovieClip;	import flash.geom.Point;		class tracker {		// last point		var lastp : Point = new Point();		// origin coordinate		var origin : Point = new Point();		// attenuation		var attenuation;				// constructor		public function tracker(xi:uint, yi:uint, att:Number = 0.80) {			origin.x = xi;			origin.y = yi;			lastp.x = xi;			lastp.y = yi;			attenuation = att;		}				// update		// sets the point to move att% into the direction of the new point		public function update(np:Point): Point {			var deltax = lastp.x - np.x;			var deltay = lastp.y - np.y;						lastp.x = np.x + attenuation * deltax;			lastp.y = np.y + attenuation * deltay;			return (lastp);		}	}